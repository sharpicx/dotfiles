"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdRenameProvider = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const path = require("path");
const lsp = require("vscode-languageserver-types");
const vscode_uri_1 = require("vscode-uri");
const position_1 = require("../types/position");
const range_1 = require("../types/range");
const dispose_1 = require("../util/dispose");
const workspace_1 = require("../workspace");
const documentLinks_1 = require("./documentLinks");
function tryDecodeUri(str) {
    try {
        return decodeURI(str);
    }
    catch {
        return str;
    }
}
class MdRenameProvider extends dispose_1.Disposable {
    constructor(configuration, workspace, referencesProvider, slugifier) {
        super();
        this.configuration = configuration;
        this.workspace = workspace;
        this.referencesProvider = referencesProvider;
        this.slugifier = slugifier;
        this.renameNotSupportedText = "Rename not supported at location";
    }
    async prepareRename(document, position, token) {
        const allRefsInfo = await this.getAllReferences(document, position, token);
        if (token.isCancellationRequested) {
            return undefined;
        }
        if (!allRefsInfo || !allRefsInfo.references.length) {
            throw new Error(this.renameNotSupportedText);
        }
        const triggerRef = allRefsInfo.triggerRef;
        switch (triggerRef.kind) {
            case 'header': {
                return { range: triggerRef.headerTextLocation.range, placeholder: triggerRef.headerText };
            }
            case 'link': {
                if (triggerRef.link.kind === 'definition') {
                    // We may have been triggered on the ref or the definition itself
                    if ((0, range_1.rangeContains)(triggerRef.link.ref.range, position)) {
                        return { range: triggerRef.link.ref.range, placeholder: triggerRef.link.ref.text };
                    }
                }
                if (triggerRef.link.href.kind === 'external') {
                    return { range: triggerRef.link.source.hrefRange, placeholder: document.getText(triggerRef.link.source.hrefRange) };
                }
                // See if we are renaming the fragment or the path
                const { fragmentRange } = triggerRef.link.source;
                if (fragmentRange && (0, range_1.rangeContains)(fragmentRange, position)) {
                    const declaration = this.findHeaderDeclaration(allRefsInfo.references);
                    if (declaration) {
                        return { range: fragmentRange, placeholder: declaration.headerText };
                    }
                    return { range: fragmentRange, placeholder: document.getText(fragmentRange) };
                }
                const range = this.getFilePathRange(triggerRef);
                if (!range) {
                    throw new Error(this.renameNotSupportedText);
                }
                return { range, placeholder: tryDecodeUri(document.getText(range)) };
            }
        }
    }
    getFilePathRange(ref) {
        if (ref.link.source.fragmentRange) {
            return (0, range_1.modifyRange)(ref.link.source.hrefRange, undefined, (0, position_1.translatePosition)(ref.link.source.fragmentRange.start, { characterDelta: -1 }));
        }
        return ref.link.source.hrefRange;
    }
    findHeaderDeclaration(references) {
        return references.find(ref => ref.isDefinition && ref.kind === 'header');
    }
    async provideRenameEdits(document, position, newName, token) {
        return (await this.provideRenameEditsImpl(document, position, newName, token))?.edit;
    }
    async provideRenameEditsImpl(document, position, newName, token) {
        const allRefsInfo = await this.getAllReferences(document, position, token);
        if (token.isCancellationRequested || !allRefsInfo || !allRefsInfo.references.length) {
            return undefined;
        }
        const triggerRef = allRefsInfo.triggerRef;
        if (triggerRef.kind === 'link' && ((triggerRef.link.kind === 'definition' && (0, range_1.rangeContains)(triggerRef.link.ref.range, position)) || triggerRef.link.href.kind === 'reference')) {
            return this.renameReferenceLinks(allRefsInfo, newName);
        }
        else if (triggerRef.kind === 'link' && triggerRef.link.href.kind === 'external') {
            return this.renameExternalLink(allRefsInfo, newName);
        }
        else if (triggerRef.kind === 'header' || (triggerRef.kind === 'link' && triggerRef.link.source.fragmentRange && (0, range_1.rangeContains)(triggerRef.link.source.fragmentRange, position) && (triggerRef.link.kind === 'definition' || triggerRef.link.kind === 'link' && triggerRef.link.href.kind === 'internal'))) {
            return this.renameFragment(allRefsInfo, newName);
        }
        else if (triggerRef.kind === 'link' && !(triggerRef.link.source.fragmentRange && (0, range_1.rangeContains)(triggerRef.link.source.fragmentRange, position)) && (triggerRef.link.kind === 'link' || triggerRef.link.kind === 'definition') && triggerRef.link.href.kind === 'internal') {
            return this.renameFilePath(triggerRef.link.source.resource, triggerRef.link.href, allRefsInfo, newName);
        }
        return undefined;
    }
    async renameFilePath(triggerDocument, triggerHref, allRefsInfo, newName) {
        const builder = new WorkspaceEditBuilder();
        const fileRenames = [];
        const targetUri = await (0, workspace_1.statLinkToMarkdownFile)(this.configuration, this.workspace, triggerHref.path) ?? triggerHref.path;
        const rawNewFilePath = (0, documentLinks_1.resolveDocumentLink)(triggerDocument, newName, this.workspace);
        if (!rawNewFilePath) {
            return { edit: builder.getEdit() };
        }
        let resolvedNewFilePath = rawNewFilePath.path;
        if (!vscode_uri_1.Utils.extname(resolvedNewFilePath)) {
            // If the newly entered path doesn't have a file extension but the original file did
            // tack on a .md file extension
            if (vscode_uri_1.Utils.extname(targetUri)) {
                resolvedNewFilePath = resolvedNewFilePath.with({
                    path: resolvedNewFilePath.path + '.md'
                });
            }
        }
        // First rename the file
        if (await this.workspace.stat(targetUri)) {
            fileRenames.push({ from: targetUri, to: resolvedNewFilePath });
            builder.renameFile(targetUri, resolvedNewFilePath);
        }
        // Then update all refs to it
        for (const ref of allRefsInfo.references) {
            if (ref.kind === 'link') {
                // Try to preserve style of existing links
                let newPath;
                if (ref.link.source.hrefText.startsWith('/')) {
                    const root = (0, documentLinks_1.resolveDocumentLink)(ref.link.source.resource, '/', this.workspace);
                    if (!root) {
                        continue;
                    }
                    newPath = '/' + path.relative(root.path.toString(true), rawNewFilePath.path.toString(true));
                }
                else {
                    const rootDir = vscode_uri_1.Utils.dirname(ref.link.source.resource);
                    if (rootDir.scheme === rawNewFilePath.path.scheme && rootDir.scheme !== 'untitled') {
                        newPath = path.relative(rootDir.toString(true), rawNewFilePath.path.toString(true));
                        if (newName.startsWith('./') && !newPath.startsWith('../') || newName.startsWith('.\\') && !newPath.startsWith('..\\')) {
                            newPath = './' + newPath;
                        }
                    }
                    else {
                        newPath = newName;
                    }
                }
                builder.replace(ref.link.source.resource, this.getFilePathRange(ref), encodeURI(newPath.replace(/\\/g, '/')));
            }
        }
        return { edit: builder.getEdit(), fileRenames };
    }
    renameFragment(allRefsInfo, newName) {
        const slug = this.slugifier.fromHeading(newName).value;
        const builder = new WorkspaceEditBuilder();
        for (const ref of allRefsInfo.references) {
            switch (ref.kind) {
                case 'header':
                    builder.replace(vscode_uri_1.URI.parse(ref.location.uri), ref.headerTextLocation.range, newName);
                    break;
                case 'link':
                    builder.replace(ref.link.source.resource, ref.link.source.fragmentRange ?? ref.location.range, !ref.link.source.fragmentRange || ref.link.href.kind === 'external' ? newName : slug);
                    break;
            }
        }
        return { edit: builder.getEdit() };
    }
    renameExternalLink(allRefsInfo, newName) {
        const builder = new WorkspaceEditBuilder();
        for (const ref of allRefsInfo.references) {
            if (ref.kind === 'link') {
                builder.replace(ref.link.source.resource, ref.location.range, newName);
            }
        }
        return { edit: builder.getEdit() };
    }
    renameReferenceLinks(allRefsInfo, newName) {
        const builder = new WorkspaceEditBuilder();
        for (const ref of allRefsInfo.references) {
            if (ref.kind === 'link') {
                if (ref.link.kind === 'definition') {
                    builder.replace(ref.link.source.resource, ref.link.ref.range, newName);
                }
                else {
                    builder.replace(ref.link.source.resource, ref.link.source.fragmentRange ?? ref.location.range, newName);
                }
            }
        }
        return { edit: builder.getEdit() };
    }
    async getAllReferences(document, position, token) {
        const version = document.version;
        if (this.cachedRefs
            && this.cachedRefs.resource.fsPath === vscode_uri_1.URI.parse(document.uri).fsPath
            && this.cachedRefs.version === document.version
            && (0, position_1.arePositionsEqual)(this.cachedRefs.position, position)) {
            return this.cachedRefs;
        }
        const references = await this.referencesProvider.getReferencesAtPosition(document, position, token);
        const triggerRef = references.find(ref => ref.isTriggerLocation);
        if (!triggerRef) {
            return undefined;
        }
        this.cachedRefs = {
            resource: vscode_uri_1.URI.parse(document.uri),
            version,
            position,
            references,
            triggerRef
        };
        return this.cachedRefs;
    }
}
exports.MdRenameProvider = MdRenameProvider;
class WorkspaceEditBuilder {
    constructor() {
        this.edit = {
            changes: {},
        };
    }
    replace(resource, range, newText) {
        const resourceKey = resource.toString();
        let edits = this.edit.changes[resourceKey];
        if (!edits) {
            edits = [];
            this.edit.changes[resourceKey] = edits;
        }
        edits.push(lsp.TextEdit.replace(range, newText));
    }
    getEdit() {
        return this.edit;
    }
    renameFile(targetUri, resolvedNewFilePath) {
        if (!this.edit.documentChanges) {
            this.edit.documentChanges = [];
        }
        this.edit.documentChanges.push(lsp.RenameFile.create(targetUri.toString(), resolvedNewFilePath.toString()));
    }
}
//# sourceMappingURL=rename.js.map