"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringiyClassname = exports.getAllClassNames = exports.filePathToClassnameDict = exports.log = exports.getWords = exports.getPosition = exports.isImportLineMatch = exports.getTransformer = exports.findImportPath = exports.genImportRegExp = exports.getCurrentDirFromUri = void 0;
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const path_1 = __importDefault(require("path"));
const os_1 = require("os");
const fs_1 = __importDefault(require("fs"));
const lodash_camelcase_1 = __importDefault(require("lodash.camelcase"));
const postcss_1 = __importDefault(require("postcss"));
const resolveAliasedImport_1 = require("./utils/resolveAliasedImport");
function getCurrentDirFromUri(uri) {
    return path_1.default.dirname(uri).replace(/^file:\/\//, '');
}
exports.getCurrentDirFromUri = getCurrentDirFromUri;
function genImportRegExp(importName) {
    const file = '(.+\\.(styl|sass|scss|less|css))';
    const fromOrRequire = '(?:from\\s+|=\\s+require(?:<any>)?\\()';
    const requireEndOptional = '\\)?';
    const pattern = `${importName}\\s+${fromOrRequire}["']${file}["']${requireEndOptional}`;
    return new RegExp(pattern);
}
exports.genImportRegExp = genImportRegExp;
function isRelativeFilePath(str) {
    return str.startsWith('../') || str.startsWith('./');
}
/**
 * Returns absolute file path to a file where css modules is from or an empty string
 *
 * @example "/users/foo/path/to/project/styles/foo.css"
 */
function findImportPath(fileContent, importName, directoryPath) {
    var _a;
    const re = genImportRegExp(importName);
    const results = re.exec(fileContent);
    if (results == null) {
        return '';
    }
    const rawImportedFrom = results[1];
    // "./style.modules.css" or "../../style.modules.css"
    if (isRelativeFilePath(rawImportedFrom)) {
        return path_1.default.resolve(directoryPath, results[1]);
    }
    return ((_a = (0, resolveAliasedImport_1.resolveAliasedImport)({
        importFilepath: rawImportedFrom,
        location: directoryPath,
    })) !== null && _a !== void 0 ? _a : '');
}
exports.findImportPath = findImportPath;
function getTransformer(camelCaseConfig) {
    switch (camelCaseConfig) {
        case true:
            /**
             * _camelCase will remove the dots in the string though if the
             * classname starts with a dot we want to preserve it
             */
            return input => `${input.charAt(0) === '.' ? '.' : ''}${(0, lodash_camelcase_1.default)(input)}`;
        case 'dashes':
            /**
             * only replaces `-` that are followed by letters
             *
             * `.foo__bar--baz` -> `.foo__barBaz`
             */
            return str => str.replace(/-+(\w)/g, (_, firstLetter) => firstLetter.toUpperCase());
        default:
            return x => x;
    }
}
exports.getTransformer = getTransformer;
function isImportLineMatch(line, matches, current) {
    if (matches === null) {
        return false;
    }
    const start1 = line.indexOf(matches[1]) + 1;
    const start2 = line.indexOf(matches[2]) + 1;
    // check current character is between match words
    return ((current > start2 && current < start2 + matches[2].length) ||
        (current > start1 && current < start1 + matches[1].length));
}
exports.isImportLineMatch = isImportLineMatch;
/**
 * Finds the position of the className in filePath
 */
function getPosition(filePath, className, camelCaseConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const classDict = yield filePathToClassnameDict(filePath, getTransformer(camelCaseConfig));
        const target = classDict[`.${className}`];
        return target
            ? vscode_languageserver_protocol_1.Position.create(target.position.line - 1, target.position.column)
            : null;
    });
}
exports.getPosition = getPosition;
function getWords(line, position) {
    const headText = line.slice(0, position.character);
    const startIndex = headText.search(/[a-z0-9\._]*$/i);
    // not found or not clicking object field
    if (startIndex === -1 || headText.slice(startIndex).indexOf('.') === -1) {
        return '';
    }
    const match = /^([a-z0-9\._]*)/i.exec(line.slice(startIndex));
    if (match === null) {
        return '';
    }
    return match[1];
}
exports.getWords = getWords;
const log = (...args) => {
    const timestamp = new Date().toLocaleTimeString('en-GB', { hour12: false });
    const msg = args
        .map(x => typeof x === 'object' ? '\n' + JSON.stringify(x, null, 2) : x)
        .join('\n\t');
    fs_1.default.appendFileSync('/tmp/log-cssmodules', `\n[${timestamp}] ${msg}\n`);
};
exports.log = log;
const sanitizeSelector = (selector) => selector
    .replace(/\\n|\\t/g, '')
    .replace(/\s+/, ' ')
    .trim();
const PostcssInst = (0, postcss_1.default)([]);
const concatSelectors = (parentSelectors, nodeSelectors) => {
    // if parent is AtRule
    if (parentSelectors.length === 0)
        return nodeSelectors;
    return [].concat(...parentSelectors.map(ps => nodeSelectors.map(
    /**
     * No need to replace for children separated by spaces
     *
     * .parent {
     *      color: red;
     *
     *      & .child {
     *      ^^^^^^^^ no need to do the replace here,
     *               since no new classnames are created
     *          color: pink;
     *      }
     * }
     */
    s => (/&[a-z0-1-_]/i ? s.replace('&', ps) : s))));
};
function getParentRule(node) {
    const { parent } = node;
    if (!parent)
        return undefined;
    if (parent.type === 'rule')
        return parent;
    return getParentRule(parent);
}
/**
 * input `'./path/to/styles.css'`
 *
 * output
 *
 * ```js
 * {
 *     '.foo': {
 *         declarations: [],
 *         position: {
 *             line: 10,
 *             column: 5,
 *         },
 *     },
 *     '.bar': {
 *         declarations: ['width: 52px'],
 *         position: {
 *             line: 22,
 *             column: 1,
 *         }
 *     }
 * }
 * ```
 */
function filePathToClassnameDict(filepath, classnameTransformer) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = fs_1.default.readFileSync(filepath, { encoding: 'utf8' });
        const { ext } = path_1.default.parse(filepath);
        /**
         * only load the parses once they are needed
         */
        const parsers = {
            '.less': () => require('postcss-less'),
            '.scss': () => require('postcss-scss'),
            '.sass': () => require('postcss-sass'),
        };
        const getParser = parsers[ext];
        /**
         * Postcss does not expose this option though typescript types
         * This is why we are doing this naughty thingy
         */
        const hiddenOption = { hideNothingWarning: true };
        const postcssOptions = Object.assign(Object.assign({ map: false, from: filepath }, hiddenOption), (typeof getParser === 'function' ? { parser: getParser() } : {}));
        const ast = yield PostcssInst.process(content, postcssOptions);
        // TODO: root.walkRules and for each rule gather info about parents
        const dict = {};
        const visitedNodes = new Map([]);
        const stack = [...ast.root.nodes];
        let commentStack = [];
        while (stack.length) {
            const node = stack.shift();
            if (node === undefined)
                continue;
            if (node.type === 'comment') {
                commentStack.push(node);
                continue;
            }
            if (node.type === 'atrule') {
                if (node.name.toLowerCase() === 'media') {
                    stack.unshift(...node.nodes);
                }
                commentStack = [];
                continue;
            }
            if (node.type !== 'rule')
                continue;
            const selectors = node.selector.split(',').map(sanitizeSelector);
            selectors.forEach(sels => {
                const classNameRe = /\.([-0-9a-z_\p{Emoji_Presentation}])+/giu;
                if (node.parent === ast.root) {
                    const match = sels.match(classNameRe);
                    match === null || match === void 0 ? void 0 : match.forEach(name => {
                        var _a, _b;
                        if (name in dict)
                            return;
                        if (node.source === undefined)
                            return;
                        const column = ((_a = node.source.start) === null || _a === void 0 ? void 0 : _a.column) || 0;
                        const line = ((_b = node.source.start) === null || _b === void 0 ? void 0 : _b.line) || 0;
                        const diff = node.selector.indexOf(name);
                        const diffStr = node.selector.slice(0, diff);
                        const lines = diffStr.split(os_1.EOL);
                        const lastLine = lines[lines.length - 1];
                        dict[classnameTransformer(name)] = {
                            declarations: node.nodes.reduce((acc, x) => {
                                if (x.type === 'decl') {
                                    acc.push(`${x.prop}: ${x.value};`);
                                }
                                return acc;
                            }, []),
                            position: {
                                column: column + lastLine.length,
                                line: line + lines.length - 1,
                            },
                            comments: commentStack.map(x => x.text),
                        };
                        commentStack = [];
                    });
                    visitedNodes.set(node, { selectors });
                }
                else {
                    if (node.parent === undefined)
                        return;
                    const parent = getParentRule(node);
                    const knownParent = parent && visitedNodes.get(parent);
                    const finishedSelectors = knownParent
                        ? concatSelectors(knownParent.selectors, selectors)
                        : selectors;
                    const finishedSelectorsAndClassNames = finishedSelectors.map(finsihedSel => finsihedSel.match(classNameRe));
                    finishedSelectorsAndClassNames.forEach(fscl => fscl === null || fscl === void 0 ? void 0 : fscl.forEach(classname => {
                        var _a, _b;
                        if (classname in dict)
                            return;
                        if (node.source === undefined)
                            return;
                        const column = ((_a = node.source.start) === null || _a === void 0 ? void 0 : _a.column) || 0;
                        const line = ((_b = node.source.start) === null || _b === void 0 ? void 0 : _b.line) || 0;
                        // TODO: refine location to specific line by the classname's last characters
                        dict[classnameTransformer(classname)] = {
                            declarations: node.nodes.reduce((acc, x) => {
                                if (x.type === 'decl') {
                                    acc.push(`${x.prop}: ${x.value};`);
                                }
                                return acc;
                            }, []),
                            position: {
                                column: column,
                                line: line,
                            },
                            comments: commentStack.map(x => x.text),
                        };
                        commentStack = [];
                    }));
                    visitedNodes.set(node, { selectors: finishedSelectors });
                }
            });
            stack.push(...node.nodes);
        }
        return dict;
    });
}
exports.filePathToClassnameDict = filePathToClassnameDict;
/**
 * Get all classnames from the file contents
 */
function getAllClassNames(filePath, keyword, classnameTransformer) {
    return __awaiter(this, void 0, void 0, function* () {
        const classes = yield filePathToClassnameDict(filePath, classnameTransformer);
        const classList = Object.keys(classes).map(x => x.slice(1));
        return keyword !== ''
            ? classList.filter(item => item.includes(keyword))
            : classList;
    });
}
exports.getAllClassNames = getAllClassNames;
function stringiyClassname(classname, declarations, comments) {
    const commentString = comments.length
        ? comments
            .map(x => {
            const lines = x.split(os_1.EOL);
            if (lines.length < 2) {
                return `/*${x} */`;
            }
            else {
                return [
                    `/*${lines[0]}`,
                    ...lines.slice(1).map(y => ` ${y.trimStart()}`),
                    ' */',
                ].join(os_1.EOL);
            }
        })
            .join(os_1.EOL) + os_1.EOL
        : '';
    return (commentString +
        [
            `.${classname} {${declarations.length ? '' : '}'}`,
            ...declarations.map(x => `  ${x}`),
            ...(declarations.length ? ['}'] : []),
        ].join(os_1.EOL));
}
exports.stringiyClassname = stringiyClassname;
